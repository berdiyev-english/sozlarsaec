<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
<title>Bewords : race</title>
<style>
  :root {
    --w: 360px;
    --h: 640px;
    --hud-bg: rgba(0,0,0,.45);
    --hud-text: #f2f2f2;
    --accent: #00c896;
    --purple-1: #7c4dff;
    --purple-2: #b388ff;
  }
  * { box-sizing: border-box; }
  html, body { height: 100%; }
  body {
    margin: 0;
    background: radial-gradient(1200px 800px at 50% -10%, #0b2e1f 0%, #061310 60%, #040a08 100%);
    color: #e8e8e8;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, "Segoe UI Emoji";
    display: grid;
    place-items: center;
    -webkit-tap-highlight-color: transparent;
  }
  .wrap {
    position: relative;
    width: min(95vw, 420px);
    aspect-ratio: 360/640;
    max-height: 95vh;
  }
  canvas {
    width: 100%;
    height: 100%;
    display: block;
    border-radius: 14px;
    box-shadow: 0 20px 60px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06);
    background: #1e1e1e;
    touch-action: none;
  }

  .hud {
    position: absolute;
    inset: 10px 10px auto 10px;
    display: flex;
    gap: 10px;
    flex-wrap: wrap;
    align-items: center;
    background: var(--hud-bg);
    padding: 8px 10px;
    border-radius: 10px;
    font-weight: 600;
    backdrop-filter: blur(6px);
    z-index: 4;
  }
  .hud b { color: var(--accent); }

  .btn {
    appearance: none;
    border: 1px solid rgba(255,255,255,.25);
    background: rgba(255,255,255,.08);
    color: #fff;
    padding: 6px 10px;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 700;
    transition: transform .06s ease, box-shadow .15s ease, background .2s ease;
  }
  .btn:active { transform: translateY(1px); }

  .btn-icon {
    width: 36px;
    height: 36px;
    padding: 0;
    display: grid;
    place-items: center;
    border-radius: 10px;
  }
  .btn-primary {
    background: linear-gradient(135deg, var(--purple-1), var(--purple-2));
    border-color: rgba(255,255,255,.25);
    box-shadow: 0 6px 20px rgba(124,77,255,.35), inset 0 0 0 1px rgba(255,255,255,.08);
  }
  .btn-primary:active { transform: translateY(1px) scale(0.99); }
  .btn-ghost {
    background: rgba(255,255,255,.08);
  }

  .overlay {
    position: absolute;
    left: 50%;
    top: 50%;
    translate: -50% -50%;
    text-align: center;
    background: var(--hud-bg);
    padding: 14px 16px;
    border-radius: 12px;
    line-height: 1.4;
    max-width: 90%;
    backdrop-filter: blur(6px);
    font-size: 14px;
    opacity: .95;
    transition: opacity .25s ease;
    z-index: 3;
    display: none;
    pointer-events: auto;
  }
  .overlay.show { display: block; }

  .menu {
    display: none;
    font-weight: 800;
    pointer-events: auto;
  }
  .menu.show { display: block; }
  .menu h2 {
    margin: 0 0 8px 0;
    font-size: 22px;
    letter-spacing: .3px;
  }

  /* –ü–∞—É–∑–∞-–ø–∞–Ω–µ–ª—å: –∫–Ω–æ–ø–∫–∏ –ø–æ —Ü–µ–Ω—Ç—Ä—É */
  .paused-actions {
    display: grid;
    gap: 10px;
    min-width: 220px;
  }
  .paused-actions .btn {
    padding: 10px 14px;
    font-size: 15px;
    border-radius: 10px;
  }

  /* –ú–æ–±–∏–ª—å–Ω—ã–µ –∑–æ–Ω—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
  .controls {
    position: absolute;
    inset: 0;
    z-index: 2;
    pointer-events: none;
  }
  .zone {
    position: absolute;
    pointer-events: auto;
    bottom: 0;
    top: 48%;
    width: 44%;
    touch-action: none; /* –í–∞–∂–Ω–æ: –æ—Ç–∫–ª—é—á–∞–µ–º –∂–µ—Å—Ç—ã/—Å–∫—Ä–æ–ª–ª –∏ —É—Å—Ç—Ä–∞–Ω—è–µ–º "–ø—Ä–∏–∑—Ä–∞—á–Ω—ã–µ" –∫–ª–∏–∫–∏ */
  }
  #zoneLeft { left: 0; }
  #zoneRight { right: 0; }

  .overlay .btn, .menu .btn { margin-top: 4px; }
</style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="360" height="640"></canvas>

    <div class="hud">
      <div>–°–∫–æ—Ä–æ—Å—Ç—å: <b><span id="speed">0</span> –∫–º/—á</b></div>
      <div>–î–∏—Å—Ç–∞–Ω—Ü–∏—è: <b><span id="distance">0.00</span> –∫–º</b></div>
      <button id="btnPause" class="btn btn-icon" data-testid="pause-button" aria-label="–ü–∞—É–∑–∞">
        <!-- –ò–∫–æ–Ω–∫–∞ –±—É–¥–µ—Ç —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—Ç—å—Å—è —Å–∫—Ä–∏–ø—Ç–æ–º -->
      </button>
      <button id="btnMute" class="btn btn-ghost" data-testid="mute-button" aria-label="–û—Ç–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫">–ó–≤—É–∫: –≤–∫–ª</button>
    </div>

    <!-- –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é -->
    <div id="menu" class="menu overlay" data-testid="menu-overlay">
      <h2>Bewords : race</h2>
      <button id="btnStart" class="btn btn-primary" data-testid="start-button" aria-label="–ù–∞—á–∞—Ç—å –∏–≥—Ä—É">–ù–∞—á–∞—Ç—å –∏–≥—Ä—É</button>
    </div>

    <!-- –ü–∞—É–∑–∞ —Å –∫–Ω–æ–ø–∫–∞–º–∏ –ø–æ —Ü–µ–Ω—Ç—Ä—É -->
    <div id="paused" class="overlay" data-testid="pause-overlay">
      <div class="paused-actions">
        <button id="btnResume" class="btn btn-primary" data-testid="resume-button" aria-label="–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–≥—Ä—É">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –∏–≥—Ä—É</button>
        <button id="btnMuteOverlay" class="btn btn-primary" data-testid="mute-button-overlay" aria-label="–ü–µ—Ä–µ–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫">–ó–≤—É–∫: –≤–∫–ª</button>
      </div>
    </div>

    <div id="gameover" class="overlay" data-testid="gameover-overlay">
      üí• –°—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–µ!<br/>
      –î–∏—Å—Ç–∞–Ω—Ü–∏—è: <span id="finalDistance">0.00</span> –∫–º<br/>
      <button id="btnRestart" class="btn btn-primary" data-testid="restart-button" aria-label="–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
    </div>

    <!-- –ú–æ–±–∏–ª—å–Ω—ã–µ –∑–æ–Ω—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
    <div class="controls" aria-hidden="true">
      <div id="zoneLeft" class="zone" data-testid="control-left"></div>
      <div id="zoneRight" class="zone" data-testid="control-right"></div>
    </div>
  </div>

<script>
/*
  –ò—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–æ–±–∏–ª—å–Ω–æ–≥–æ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è:
  –†–∞–Ω–µ–µ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —Å—Ä–∞–±–∞—Ç—ã–≤–∞–ª–∏ –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ touchstart –∏ pointerdown,
  –∏–∑-–∑–∞ —á–µ–≥–æ –∑–∞ –æ–¥–Ω–æ –Ω–∞–∂–∞—Ç–∏–µ –≤—ã–ø–æ–ª–Ω—è–ª–æ—Å—å –¥–≤–∞ —à–∞–≥–∞ (—Å –ª–µ–≤–æ–≥–æ –∫—Ä–∞—è —Å—Ä–∞–∑—É –Ω–∞ –ø—Ä–∞–≤—ã–π –∏ –Ω–∞–æ–±–æ—Ä–æ—Ç).
  –¢–µ–ø–µ—Ä—å –∏—Å–ø–æ–ª—å–∑—É–µ–º –¢–û–õ–¨–ö–û pointerdown (–µ—Å–ª–∏ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è), –∞ touchstart ‚Äî —Ç–æ–ª—å–∫–æ –∫–∞–∫ –∑–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç.
*/
(() => {
  const W = 360, H = 640;

  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const elSpeed = document.getElementById('speed');
  const elDistance = document.getElementById('distance');
  const elPaused = document.getElementById('paused');
  const elGameOver = document.getElementById('gameover');
  const elFinalDistance = document.getElementById('finalDistance');
  const elMenu = document.getElementById('menu');

  const btnPause = document.getElementById('btnPause');
  const btnRestart = document.getElementById('btnRestart');
  const btnMute = document.getElementById('btnMute');
  const btnStart = document.getElementById('btnStart');
  const btnResume = document.getElementById('btnResume');
  const btnMuteOverlay = document.getElementById('btnMuteOverlay');

  const zoneLeft = document.getElementById('zoneLeft');
  const zoneRight = document.getElementById('zoneRight');

  const lanes = 3;
  const roadMargin = 60;
  const roadX = roadMargin;
  const roadW = W - roadMargin * 2;
  const laneW = roadW / lanes;

  const carW = Math.round(laneW * 0.58);
  const carH = Math.round(laneW * 1.10);
  const carY = H - carH - 18;

  const minSpeed = 140;
  const maxSpeed = 420;
  let roadSpeed = 160;
  const accel = 22;

  const M_PER_PX = 0.05;

  let currentLane = 1;
  let targetLane = 1;
  let carX = laneCenter(currentLane) - carW / 2;
  const carColor = '#ff3b3b';

  const cars = [];
  let scrollAcc = 0;
  let prevFreeLane = 1;

  let hitFlash = 0;
  let shakeT = 0;

  let distanceMeters = 0;
  let paused = false;
  let gameOver = false;
  let inMenu = true;

  // –ê—É–¥–∏–æ —Å ¬´–ø–µ—Ä–µ–¥–∞—á–∞–º–∏¬ª
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;

  const gearKm = [0, 22, 38, 55, 76]; // 4 –ø–µ—Ä–µ–¥–∞—á–∏
  let currentGear = 0;
  let shiftEndTime = 0;

  let engineOsc = null;
  let engineSubOsc = null;
  let engineFilter = null;
  let engineSubFilter = null;
  let engineGain = null;
  let engineSubGain = null;
  let masterGain = null;
  let muted = false;

  function ensureAudio() {
    if (!AudioCtx) return;
    if (!audioCtx) audioCtx = new AudioCtx();
    if (audioCtx.state === 'suspended') audioCtx.resume();
    ensureEngine();
  }

  function ensureEngine() {
    if (!audioCtx || engineOsc) return;

    masterGain = audioCtx.createGain();
    masterGain.gain.value = 1.0;

    engineOsc = audioCtx.createOscillator();
    engineOsc.type = 'triangle';
    engineFilter = audioCtx.createBiquadFilter();
    engineFilter.type = 'lowpass';
    engineFilter.frequency.value = 900;
    engineGain = audioCtx.createGain();
    engineGain.gain.value = 0.0;

    engineSubOsc = audioCtx.createOscillator();
    engineSubOsc.type = 'sine';
    engineSubFilter = audioCtx.createBiquadFilter();
    engineSubFilter.type = 'lowpass';
    engineSubFilter.frequency.value = 500;
    engineSubGain = audioCtx.createGain();
    engineSubGain.gain.value = 0.0;

    engineOsc.connect(engineFilter).connect(engineGain).connect(masterGain).connect(audioCtx.destination);
    engineSubOsc.connect(engineSubFilter).connect(engineSubGain).connect(masterGain).connect(audioCtx.destination);

    engineOsc.start();
    engineSubOsc.start();

    refreshAudioState();
  }

  function kmhFromSpeed() { return roadSpeed * (M_PER_PX * 3.6); }

  function pickGear(kmh) {
    for (let i = gearKm.length - 1; i >= 0; i--) if (kmh >= gearKm[i]) return i;
    return 0;
  }

  function updateEngineAudio() {
    if (!audioCtx || !engineOsc || !engineGain) return;

    const now = audioCtx.currentTime;
    const kmh = kmhFromSpeed();
    const nextGear = pickGear(kmh);

    if (nextGear > currentGear) {
      currentGear = nextGear;
      shiftEndTime = now + 0.16;
      engineGain.gain.setTargetAtTime(0.01, now, 0.02);
      engineSubGain.gain.setTargetAtTime(0.005, now, 0.02);
      engineFilter.frequency.setTargetAtTime(700, now, 0.02);
      engineSubFilter.frequency.setTargetAtTime(400, now, 0.02);
    }

    const gStart = gearKm[Math.max(0, currentGear)];
    const gEnd = gearKm[Math.min(gearKm.length - 1, currentGear + 1)];
    const span = Math.max(6, gEnd - gStart);
    const rpmN = clamp((kmh - gStart) / span, 0, 1);

    const targetHz = 70 + rpmN * 100;
    const subHz = Math.max(35, targetHz * 0.5);

    const targetVol = (muted || paused || gameOver || inMenu) ? 0 : clamp(0.02 + rpmN * 0.045, 0, 0.06);
    const targetSubVol = (muted || paused || gameOver || inMenu) ? 0 : clamp(0.01 + rpmN * 0.03, 0, 0.035);

    const shifting = now < shiftEndTime;

    if (shifting) {
      engineOsc.frequency.setTargetAtTime(Math.max(55, targetHz * 0.7), now, 0.03);
      engineSubOsc.frequency.setTargetAtTime(Math.max(28, subHz * 0.7), now, 0.03);
      engineFilter.frequency.setTargetAtTime(750, now, 0.03);
      engineSubFilter.frequency.setTargetAtTime(420, now, 0.03);
      engineGain.gain.setTargetAtTime(targetVol, shiftEndTime, 0.06);
      engineSubGain.gain.setTargetAtTime(targetSubVol, shiftEndTime, 0.06);
    } else {
      engineOsc.frequency.setTargetAtTime(targetHz, now, 0.06);
      engineSubOsc.frequency.setTargetAtTime(subHz, now, 0.06);
      engineFilter.frequency.setTargetAtTime(800 + rpmN * 500, now, 0.06);
      engineSubFilter.frequency.setTargetAtTime(450 + rpmN * 150, now, 0.06);
      engineGain.gain.setTargetAtTime(targetVol, now, 0.06);
      engineSubGain.gain.setTargetAtTime(targetSubVol, now, 0.06);
    }
  }

  function refreshAudioState() {
    if (!audioCtx || !masterGain || !engineGain || !engineSubGain) return;
    const kmh = kmhFromSpeed();
    const rpmN = clamp(kmh / 80, 0, 1);
    const vol = (muted || paused || gameOver || inMenu) ? 0 : clamp(0.02 + rpmN * 0.045, 0, 0.06);
    const subVol = (muted || paused || gameOver || inMenu) ? 0 : clamp(0.01 + rpmN * 0.03, 0, 0.035);
    engineGain.gain.setValueAtTime(vol, audioCtx.currentTime);
    engineSubGain.gain.setValueAtTime(subVol, audioCtx.currentTime);
    masterGain.gain.setValueAtTime(muted ? 0 : 1, audioCtx.currentTime);
  }

  function sfxCrash() {
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime;
    const bufferSize = 0.1 * audioCtx.sampleRate;
    const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    const noise = audioCtx.createBufferSource();
    noise.buffer = noiseBuffer;
    const nGain = audioCtx.createGain();
    nGain.gain.setValueAtTime(0.18, t0);
    nGain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.1);
    noise.connect(nGain).connect(audioCtx.destination);
    noise.start(t0);
    noise.stop(t0 + 0.12);

    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(160, t0);
    osc.frequency.exponentialRampToValueAtTime(70, t0 + 0.22);
    gain.gain.setValueAtTime(0.12, t0);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.24);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + 0.25);

    if (navigator.vibrate) navigator.vibrate(140);
  }

  function sfxGameOver() {
    if (!audioCtx) return;
    const t0 = audioCtx.currentTime + 0.05;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(420, t0);
    osc.frequency.exponentialRampToValueAtTime(220, t0 + 0.35);
    gain.gain.setValueAtTime(0.001, t0);
    gain.gain.exponentialRampToValueAtTime(0.1, t0 + 0.05);
    gain.gain.exponentialRampToValueAtTime(0.0001, t0 + 0.38);
    osc.connect(gain).connect(audioCtx.destination);
    osc.start(t0);
    osc.stop(t0 + 0.4);
  }

  // –£—Ç–∏–ª–∏—Ç—ã
  function laneCenter(i) { return roadX + laneW * i + laneW / 2; }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function choice(arr) { return arr[Math.floor(Math.random() * arr.length)]; }
  function lerp(a,b,t) { return a + (b - a) * t; }
  function roundRect(ctx, x, y, w, h, r) {
    r = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
  }

  // –ò–∫–æ–Ω–∫–∏ –¥–ª—è –∫–Ω–æ–ø–∫–∏ –ø–∞—É–∑—ã
  function svgPause() {
    return '<svg width="18" height="18" viewBox="0 0 24 24" fill="#fff" xmlns="http://www.w3.org/2000/svg"><rect x="6" y="5" width="4" height="14" rx="1.5"/><rect x="14" y="5" width="4" height="14" rx="1.5"/></svg>';
  }
  function svgPlay() {
    return '<svg width="18" height="18" viewBox="0 0 24 24" fill="#fff" xmlns="http://www.w3.org/2000/svg"><path d="M8 5v14l11-7-11-7z"/></svg>';
  }
  function updatePauseIcon() {
    btnPause.innerHTML = paused ? svgPlay() : svgPause();
    btnPause.setAttribute('aria-label', paused ? '–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å' : '–ü–∞—É–∑–∞');
  }

  // –í–≤–æ–¥ —Å –∫–ª–∞–≤–∏–∞—Ç—É—Ä—ã
  document.addEventListener('keydown', (e) => {
    const c = e.code;
    ensureAudio();
    if (inMenu) {
      if (c === 'Enter' || c === 'Space') { e.preventDefault(); startGame(); }
      return;
    }
    if (gameOver) {
      if (c === 'KeyR' || c === 'Enter' || c === 'Space') { e.preventDefault(); restart(); }
      return;
    }
    if (c === 'ArrowLeft' || c === 'KeyA') { e.preventDefault(); moveLeft(); }
    if (c === 'ArrowRight' || c === 'KeyD') { e.preventDefault(); moveRight(); }
    if (c === 'KeyP') { e.preventDefault(); togglePause(); }
    if (c === 'KeyM') { e.preventDefault(); toggleMute(); }
  });

  btnPause.addEventListener('click', () => { ensureAudio(); togglePause(); });
  btnRestart.addEventListener('click', () => { ensureAudio(); restart(); });
  btnMute.addEventListener('click', () => { ensureAudio(); toggleMute(); });
  btnStart.addEventListener('click', () => { ensureAudio(); startGame(); });

  btnResume.addEventListener('click', () => { ensureAudio(); if (paused) togglePause(); });
  btnMuteOverlay.addEventListener('click', () => { ensureAudio(); toggleMute(); });

  function updateMuteUI() {
    const label = muted ? '–ó–≤—É–∫: –≤—ã–∫–ª' : '–ó–≤—É–∫: –≤–∫–ª';
    btnMute.textContent = label;
    btnMuteOverlay.textContent = label;
    btnMute.setAttribute('aria-label', muted ? '–í–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫' : '–û—Ç–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫');
    btnMuteOverlay.setAttribute('aria-label', muted ? '–í–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫' : '–û—Ç–∫–ª—é—á–∏—Ç—å –∑–≤—É–∫');
  }

  function toggleMute() {
    muted = !muted;
    updateMuteUI();
    refreshAudioState();
  }

  function moveLeft() {
    if (paused || gameOver || inMenu) return;
    targetLane = Math.max(0, targetLane - 1);
  }
  function moveRight() {
    if (paused || gameOver || inMenu) return;
    targetLane = Math.min(lanes - 1, targetLane + 1);
  }

  function togglePause() {
    if (gameOver || inMenu) return;
    paused = !paused;
    elPaused.classList.toggle('show', paused);
    updatePauseIcon();
    updateMuteUI();
    refreshAudioState();
  }

  function startGame() {
    inMenu = false;
    paused = false;
    gameOver = false;
    elMenu.classList.remove('show');
    elPaused.classList.remove('show');
    elGameOver.classList.remove('show');
    updatePauseIcon();
    ensureAudio();
    updateMuteUI();
    refreshAudioState();
  }

  // –¢–∞—á/—É–∫–∞–∑–∞—Ç–µ–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
  function bindZone(zone, action) {
    const start = (e) => {
      // –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ–º –¥–≤–æ–π–Ω—ã–µ —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è –∏ "–ø—Ä–∏–∑—Ä–∞—á–Ω—ã–µ" –∫–ª–∏–∫–∏
      if (e && typeof e.preventDefault === 'function') e.preventDefault();
      ensureAudio();
      if (!inMenu) action();
    };

    if ('onpointerdown' in window) {
      // –°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø—É—Ç—å: –µ–¥–∏–Ω—ã–π pointerdown (–∏ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö, –∏ –¥–ª—è –¥–µ—Å–∫—Ç–æ–ø–∞)
      zone.addEventListener('pointerdown', start, { passive: false });
    } else if ('ontouchstart' in window) {
      // –ó–∞–ø–∞—Å–Ω–æ–π –≤–∞—Ä–∏–∞–Ω—Ç –¥–ª—è –æ—á–µ–Ω—å —Å—Ç–∞—Ä—ã—Ö –±—Ä–∞—É–∑–µ—Ä–æ–≤ (–±–µ–∑ Pointer Events)
      zone.addEventListener('touchstart', start, { passive: false });
    } else {
      // –°–∞–º–∞—è –±–∞–∑–æ–≤–∞—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å
      zone.addEventListener('mousedown', start, { passive: false });
    }
  }
  bindZone(zoneLeft, moveLeft);
  bindZone(zoneRight, moveRight);

  // –¶–∏–∫–ª
  let prev = performance.now();
  elMenu.classList.add('show');
  updatePauseIcon();
  updateMuteUI();
  requestAnimationFrame(loop);

  function loop(t) {
    const dt = Math.min(0.033, (t - prev) / 1000);
    prev = t;

    if (!paused && !gameOver && !inMenu) update(dt);
    render();

    requestAnimationFrame(loop);
  }

  function update(dt) {
    roadSpeed = clamp(roadSpeed + accel * dt, minSpeed, maxSpeed);

    const targetX = laneCenter(targetLane) - carW / 2;
    const lerpK = 16;
    carX += (targetX - carX) * Math.min(1, dt * lerpK);

    distanceMeters += roadSpeed * dt * M_PER_PX;

    const difficultyT = clamp(distanceMeters / 3000, 0, 1);

    const rowGapPx = Math.round(lerp(270, 140, difficultyT));
    scrollAcc += roadSpeed * dt;
    if (scrollAcc >= rowGapPx) {
      spawnRow(difficultyT);
      scrollAcc = 0;
    }

    for (let i = cars.length - 1; i >= 0; i--) {
      const o = cars[i];
      o.y += (roadSpeed * o.speedMul) * dt;
      if (o.y > H + 120) cars.splice(i, 1);
    }

    const player = { x: carX, y: carY, w: carW, h: carH };
    for (let i = 0; i < cars.length; i++) {
      const o = cars[i];
      if (!(player.x + player.w < o.x ||
            player.x > o.x + o.w ||
            player.y + player.h < o.y ||
            player.y > o.y + o.h)) {
        onHit();
        break;
      }
    }

    if (hitFlash > 0) hitFlash -= dt;
    if (shakeT > 0) shakeT -= dt;

    const kmh = roadSpeed * (M_PER_PX * 3.6);
    elSpeed.textContent = Math.round(kmh);
    elDistance.textContent = (distanceMeters / 1000).toFixed(2);

    updateEngineAudio();
  }

  function spawnRow(difficultyT) {
    const delta = choice([-1, 0, 1]);
    let freeLane = clamp(prevFreeLane + delta, 0, lanes - 1);

    const twoCarsChance = lerp(0.15, 0.82, difficultyT);
    const spawnTwo = Math.random() < twoCarsChance;

    const allLanes = [0,1,2];
    const blocked = allLanes.filter(l => l !== freeLane);

    let lanesToSpawn;
    if (spawnTwo) lanesToSpawn = blocked;
    else lanesToSpawn = [choice(blocked)];

    const palette = ['#40c4ff','#ffd740', '#ff7043', '#7e57c2', '#26a69a', '#ef5350', '#90caf9', '#81c784'];
    const baseY = -carH - 20;

    lanesToSpawn.forEach((lane, idx) => {
      const x = laneCenter(lane) - carW / 2;
      const yJitter = spawnTwo ? (idx === 0 ? 0 : Math.random() * 14) : 0;
      const y = baseY - yJitter;
      const speedMul = lerp(0.985, 1.03, Math.random());
      const color = choice(palette);
      cars.push({ lane, x, y, w: carW, h: carH, color, speedMul });
    });

    prevFreeLane = freeLane;
  }

  function onHit() {
    ensureAudio();
    gameOver = true;
    hitFlash = 0.35;
    shakeT = 0.45;
    elFinalDistance.textContent = (distanceMeters / 1000).toFixed(2);
    elGameOver.classList.add('show');
    elPaused.classList.remove('show');
    sfxCrash();
    sfxGameOver();
    refreshAudioState();
  }

  function restart() {
    cars.length = 0;
    distanceMeters = 0;
    roadSpeed = 160;
    currentLane = 1;
    targetLane = 1;
    carX = laneCenter(currentLane) - carW / 2;
    prevFreeLane = 1;
    scrollAcc = 0;
    hitFlash = 0;
    shakeT = 0;
    gameOver = false;
    paused = false;
    inMenu = false;
    elGameOver.classList.remove('show');
    elPaused.classList.remove('show');
    elMenu.classList.remove('show');
    updatePauseIcon();
    ensureAudio();
    updateMuteUI();
    refreshAudioState();
  }

  // –†–µ–Ω–¥–µ—Ä
  function render() {
    const shakeAmt = (shakeT > 0) ? (6 * Math.pow(shakeT, 0.6)) : 0;
    const sx = (Math.random() * 2 - 1) * shakeAmt;
    const sy = (Math.random() * 2 - 1) * shakeAmt;

    ctx.save();
    ctx.clearRect(0, 0, W, H);
    ctx.translate(sx, sy);

    drawBackground();
    drawRoad();
    drawLaneMarks();
    drawTraffic();
    drawPlayer();

    if (hitFlash > 0) {
      const a = Math.max(0, Math.min(0.35, hitFlash * 1.5));
      ctx.fillStyle = `rgba(255,0,0,${a})`;
      ctx.fillRect(0, 0, W, H);
    }

    ctx.restore();
  }

  function drawBackground() {
    const grd = ctx.createLinearGradient(0, 0, 0, H);
    grd.addColorStop(0, '#0f6a3c');
    grd.addColorStop(1, '#0b4d2d');
    ctx.fillStyle = grd;
    ctx.fillRect(0, 0, W, H);
  }
  function drawRoad() {
    const roadGr = ctx.createLinearGradient(0, 0, 0, H);
    roadGr.addColorStop(0, '#2a2f35');
    roadGr.addColorStop(1, '#1d2226');
    ctx.fillStyle = roadGr;
    ctx.fillRect(roadX, 0, roadW, H);
    ctx.fillStyle = '#d0d0d0';
    ctx.fillRect(roadX - 4, 0, 4, H);
    ctx.fillRect(roadX + roadW, 0, 4, H);
  }
  function drawLaneMarks() {
    ctx.save();
    ctx.strokeStyle = '#e8e8e8';
    ctx.lineWidth = 3;
    const dash = [18, 18];
    ctx.setLineDash(dash);
    const dashOffset = (distanceMeters / M_PER_PX) % (dash[0] + dash[1]);
    ctx.lineDashOffset = -dashOffset;
    for (let i = 1; i < lanes; i++) {
      const x = roadX + laneW * i;
      ctx.beginPath();
      ctx.moveTo(x, -20);
      ctx.lineTo(x, H + 20);
      ctx.stroke();
    }
    ctx.restore();
  }
  function drawTraffic() {
    for (const o of cars) drawCarShape(o.x, o.y, o.w, o.h, o.color, true);
  }
  function drawPlayer() {
    drawCarShape(carX, carY, carW, carH, carColor, false);
  }
  function drawCarShape(x, y, w, h, color, withRoof) {
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    roundRect(ctx, x + 4, y + 6, w, h, 10); ctx.fill();

    const gr = ctx.createLinearGradient(x, y, x, y + h);
    gr.addColorStop(0, lighten(color, 0.18));
    gr.addColorStop(1, darken(color, 0.18));
    ctx.fillStyle = gr;
    roundRect(ctx, x, y, w, h, 12); ctx.fill();

    if (withRoof) {
      ctx.fillStyle = 'rgba(255,255,255,0.13)';
      roundRect(ctx, x + w*0.18, y + h*0.15, w*0.64, h*0.38, 8); ctx.fill();
    } else {
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      roundRect(ctx, x + w*0.18, y + h*0.12, w*0.64, h*0.42, 8); ctx.fill();
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      roundRect(ctx, x + w*0.2, y + h*0.64, w*0.6, h*0.06, 6); ctx.fill();
    }

    ctx.fillStyle = '#111';
    const wheelW = w * 0.22, wheelH = h * 0.18;
    roundRect(ctx, x - wheelW * 0.6, y + h * 0.18, wheelW, wheelH, 4); ctx.fill();
    roundRect(ctx, x - wheelW * 0.6, y + h * 0.66, wheelW, wheelH, 4); ctx.fill();
    roundRect(ctx, x + w - wheelW * 0.4, y + h * 0.18, wheelW, wheelH, 4); ctx.fill();
    roundRect(ctx, x + w - wheelW * 0.4, y + h * 0.66, wheelW, wheelH, 4); ctx.fill();
  }

  function hexToRgb(hex) {
    const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
    return m ? { r: parseInt(m[1], 16), g: parseInt(m[2], 16), b: parseInt(m[3], 16) } : { r: 255, g: 64, b: 64 };
  }
  function rgbToHex({r,g,b}) {
    return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
  }
  function lighten(hex, p=0.1) {
    const c = hexToRgb(hex);
    c.r = Math.round(c.r + (255 - c.r) * p);
    c.g = Math.round(c.g + (255 - c.g) * p);
    c.b = Math.round(c.b + (255 - c.b) * p);
    return rgbToHex(c);
  }
  function darken(hex, p=0.1) {
    const c = hexToRgb(hex);
    c.r = Math.round(c.r * (1 - p));
    c.g = Math.round(c.g * (1 - p));
    c.b = Math.round(c.b * (1 - p));
    return rgbToHex(c);
  }
})();
</script>
</body>
</html>